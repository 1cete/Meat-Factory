import socket
import random
import os
import time
import math
import sys, select

SOKETO_FAILAS = "./zaidimas.sock"
ZAIDIMO_STATISTIKA = "./taskai.dat"



###############################################################################
def rasykStatistika(klientas):
    failas = open(ZAIDIMO_STATISTIKA, 'a')
    failas.write(f'{klientas}\n')
    failas.close()
  
###############################################################################
#ANMACIJA

def rodyti_animacija_klientui(klientas):
    
    '''Siunčiame animacijos kadrus kas ~0.1 s.
    Tarp kadru tikriname, ar nėra komandos 'STOP_ANIM' iš kliento.'''

    pavadinimas = "UAB ŠLAPIANKA"
    plotis = 80
    aukstis = 20
    pavadinimo_ilgis = len(pavadinimas)
    t = 0

    # Padarome socket neblokuojantį (kad recv nestringtų).
    # Arba galėtume naudoti select() mechanizmą, bet neblokuojantis recv paprasčiau.
    klientas.setblocking(False)

    try:
        while True:
            # 1) Tikriname, ar klientas kažko nesiuntė (pvz. STOP_ANIM)
            try:
                data = klientas.recv(4096)
                if data:
                    tekstas = data.decode('utf-8').strip()
                    if tekstas == "STOP_ANIM":
                        # Sustabdome animaciją
                        break
                    # Jei kažkas kito - ignoruojam arba apdorojam
            except BlockingIOError:
                # Reiškia - šiuo momentu nėra gautų duomenų.
                pass

            # 2) Sudarome kadrą su ANSI sekų išvalymu
            kadras = "\x1b[2J\x1b[H"
            vertikali_padetis = int((math.sin(t) + 1) * (aukstis // 4))
            horizontali_padetis = int((t * 2) % (plotis + pavadinimo_ilgis)) - pavadinimo_ilgis

            kadras += "\n" * vertikali_padetis
            if horizontali_padetis >= 0:
                kadras += (" " * horizontali_padetis) + pavadinimas + "\n"

            # 3) Siunčiame kadrą
            klientas.sendall(kadras.encode('utf-8'))

            # Pauzė tarp kadrų
            time.sleep(0.1)
            t += 0.2

    except (BrokenPipeError, ConnectionResetError):
        print("Klientas atjungė ryšį animacijos metu.")
    finally:
        # Svarbu: grąžiname socket į blocking režimą, jei norime toliau normaliai priiminėti duomenis
        klientas.setblocking(True)

'''#ANIMACIJA PABAIGA
###############################################################################'''

class Klientas:
    def __init__(self, vardas):
        self.vardas = vardas
        self.pinigai = 50
        self.mesa = 50  
        self.pakuotes = 5  
        self.uzsakymai = []  
        self.masina_sugedo = False
        self.reali_praejo_laikas = 0 

    def __str__(self):
        return f'{self.vardas};{self.pinigai};{self.mesa};{self.pakuotes};{self.uzsakymai};{self.masina_sugedo};{self.reali_praejo_laikas}'

class Uzsakymas:
    def __init__(self, kiekis, pakuotes, laiko_trukme):
        self.kiekis = kiekis
        self.pakuotes = pakuotes
        self.laiko_trukme = laiko_trukme  
        self.laiko_pradzia = 0  
        self.pelnas = (kiekis * 2) + (pakuotes * 2)  
        self.delspinigiai = 0  
        self.laiko_pabaiga = 0  
        self.ivykdytas = False 

##### sita gal kur kitur ikisti

    def nustatyti_laiko_pabaiga(self, laiko_pradzia):
        self.laiko_pabaiga = laiko_pradzia + self.laiko_trukme * 24 * 60 * 60 
        #Trukmė sekundėmis

    def pridet_delspinigiai(self, realus_praeje_laikas):
        if self.ivykdytas:
            return     # Jei užsakymas buvo įvykdytas, delspinigiai nepridedami

        if realus_praeje_laikas >= self.laiko_pabaiga:
            delspinigiai = (realus_praeje_laikas - self.laiko_pabaiga) // 20
            self.delspinigiai += delspinigiai
#####

    def __str__(self):
        return f'{self.kiekis};{self.pakuotes};{self.laiko_trukme};{self.laiko_pradzia};{self.pelnas};{self.delspinigiai};{self.laiko_pabaiga};{self.ivykdytas}'

###############################################################################
#Man atrodo vietoje 'zaidejas' turi buti 'klientas' bet gal veiks


def parodyti_uzsakymus(zaidejas):
    """Grąžina tekstinę informaciją apie užsakymus."""
    if zaidejas.uzsakymai:
        eilutes = []
        for i, u in enumerate(zaidejas.uzsakymai):
            likusios_sekundes = max(u.laiko_pabaiga - zaidejas.reali_praejo_laikas, 0)
            likusios_dienos = likusios_sekundes // (24 * 60 * 60)
            delspinigiai = u.delspinigiai if not u.ivykdytas else 0

            eilute = (f"{i + 1}. Kiekis: {u.kiekis} kg, Pakuotės: {u.pakuotes}, "
                      f"Liko: {likusios_dienos} d., Delspinigiai: {delspinigiai}€")
            eilutes.append(eilute)

        # Surenkame visas eilutes į vieną, su \n tarp jų
        return "\n".join(eilutes) + "\n"
    else:
        return "Šiuo metu nėra užsakymų.\n"

###############################################################################



def naujas_uzsakymas(zaidejas):
    kiekis = random.randint(5, 30)  # Užsakymo kiekis (5-30 kg)
    pakuotes = random.randint(1, 10)  # Užsakymo pakuotės (1-10)
    laiko_trukme = random.choice([1, 2, 3, 4])  # Laiko trukmė (1-4 paros)

    uzsakymas = Uzsakymas(kiekis, pakuotes, laiko_trukme)
    uzsakymas.laiko_pradzia = zaidejas.reali_praejo_laikas
    uzsakymas.nustatyti_laiko_pabaiga(zaidejas.reali_praejo_laikas)

    zaidejas.uzsakymai.append(uzsakymas)

    # Vietoj print() grąžinsime eilutę, kad galėtume išsiųsti klientui
    return (
        f"Padarėte naują užsakymą: {kiekis} kg mėsos ir {pakuotes} pakuočių.\n"
        f"Trukmė: {laiko_trukme} paros\n"
    )

###############################################################################
def uzsakymu_sarasas_tekstu(zaidejas):
    """
    Sudaro eilutę (ar kelias eilutes) su visais žaidėjo užsakymais.
    Jei nėra užsakymų, grąžina 'Šiuo metu nėra užsakymų.'.
    """
    if not zaidejas.uzsakymai:
        return "Šiuo metu nėra užsakymų.\n"

    eilutes = []
    for i, u in enumerate(zaidejas.uzsakymai, start=1):
        likusios_sekundes = max(u.laiko_pabaiga - zaidejas.reali_praejo_laikas, 0)
        likusios_dienos = likusios_sekundes // (24 * 60 * 60)
        delspinigiai = u.delspinigiai if not u.ivykdytas else 0

        eilute = (f"{i}. Kiekis: {u.kiekis} kg, pakuotės: {u.pakuotes}, liko: {likusios_dienos} d., delspinigiai: {delspinigiai}€")
        eilutes.append(eilute)
    # Sudedame eilutes į vieną tekstą su \n tarp jų
    return "\n".join(eilutes) + "\n"
##############################################################################

def pirkti_resursus(zaidejas, pasirinkimas):
    """
    Grąžina eilutę, kurią vėliau serveris nusiųs klientui.
    Parametras 'pasirinkimas' turėtų būti '1' arba '2'.
    """
    atsakymas = ""
    atsakymas += "Parduotuvių pasirinkimai:\n"
    atsakymas += "1. Ūkininkas Antanas - Mėsos 10 kg už 10€\n"
    atsakymas += "2. Pakuočių parduotuvė - 5 pakuotės už 5€\n"

    if pasirinkimas == "1":
        atsakymas += "                                                         .'T'. - -'.\n"
        atsakymas += "                                                      .'/|||||\\'. - -'.\n"
        atsakymas += "                                                    .'/|||||||||\\'. - -'.\n"
        atsakymas += "                                                  .'/|||||___|||||\\'. - -'.\n"
        atsakymas += "    Jūs pasirinkote ūkininką Antaną!             //|||||||||||||||||\\\\ - - \\\n"
        atsakymas += "                                                //|||||||||||||||||||\\\\ - - \\  /|\\   Perduok linkėjimus šeimai!!\n"
        atsakymas += "                                               //|||||||||||||||||||||\\\\_____/\\//|\\\\               .\n"
        atsakymas += "                                                |||||||||||||||||||||| |||||  //|\\\\                .\n"
        atsakymas += "                         ____________::___      ||||||||||ldb||||||||| ||||| ///|\\\\\\             _/V\\_ \n"
        atsakymas += "          _        _    /_)_)_)_)_)_)_)_)/\\     ||||| \\       // |||| ||||| ///|\\\\\\              (d_b) ,\n"
        atsakymas += "         ( )_    _( )  /_)_)_)_)_)_)_)_)/ _\\    |||||   \\   //   |||| |||||////|\\\\\\\\           .__/Y\\_/\n"
        atsakymas += "        (  )_)  (  )_)  | :__:    :__: |: |     |||||     \\x\\     |||| |||||////|\\\\\\\\             |I|\n"
        atsakymas += "       (_(_ (_)(_) _)_) |  _   .-.   _ | :|     |||||   //   \\\\   |||| ||||/////|\\\\\\\\\\            / |\n"
        atsakymas += "     ____)\_(____)_/(___|_'_'o8|'|8o'_'|:_o8o._.o8%8o_//_______\\\\_||||.o88o8&8o)/(88o.____       _| |_ \n"

        if zaidejas.pinigai >= 10:
            zaidejas.mesa += 10
            zaidejas.pinigai -= 10
            atsakymas += "\n"
            atsakymas += "Įsigijote 10 kg mėsos.\n"
        else:
            atsakymas += "Nepakanka pinigų!\n"

    elif pasirinkimas == "2":
        atsakymas += "                                         .---__----.\n" 
        atsakymas += "                                       ;-------------.| \n"
        atsakymas += "                                       |             ||    .--__---. \n"
        atsakymas += " Jūs pasirinkote pakuočių parduotuvę!  |             ||  ;-----------.|\n"
        atsakymas += "                                       |             ||  |           ||\n"
        atsakymas += "                                       |_____________|/  |           ||\n"
        atsakymas += "                                                         |___________|/\n"
        if zaidejas.pinigai >= 5:
            zaidejas.pakuotes += 5
            zaidejas.pinigai -= 5
            atsakymas += "Įsigijote 5 pakuotes.\n"
        else:
            atsakymas += "Nepakanka pinigų!\n"
    else:
        atsakymas += "Neteisingas pasirinkimas!\n"

    return atsakymas


##############################################################################


def vykdyti_uzsakyma(zaidejas, uzsakymas_index):
    """
    Grąžina tekstą, kurį serveris persiųs klientui (vietoj print).
    """
    atsakymas = ""
    try:
        uzsakymas = zaidejas.uzsakymai[uzsakymas_index]

        if zaidejas.mesa >= uzsakymas.kiekis and zaidejas.pakuotes >= uzsakymas.pakuotes:
            zaidejas.mesa -= uzsakymas.kiekis
            zaidejas.pakuotes -= uzsakymas.pakuotes
            zaidejas.pinigai += uzsakymas.pelnas
            uzsakymas.ivykdytas = True
            atsakymas += (
                f"Užsakymas įvykdytas: {uzsakymas.kiekis} kg mėsos, "
                f"{uzsakymas.pakuotes} pakuočių.\n"
            )
            # Pašaliname užsakymą iš sąrašo
            del zaidejas.uzsakymai[uzsakymas_index]
        else:
            atsakymas += "Nepakanka resursų užsakymui atlikti.\n"
    except IndexError:
        atsakymas += "Tokio užsakymo nėra!\n"

    return atsakymas


##############################################################################
def gaminti_mesos_produktus(zaidejas, komanda):
    """
    komanda - string, pvz. "1 3" (gaminsime Nr.1, 3 vnt)
    Grąžiname eilutę, kurią serveris vėliau išsiųs klientui.
    """
    dalys = komanda.split()
    if len(dalys) != 2:
        return "Neteisingas formatas! Pvz: '1 5' (gaminys 1, 5 vienetų)\n"

    pasirinkimas, kiek_vienetu_str = dalys
    atsakymas = ""
    atsakymas += "Mėsos produktų gamyba:\n"
    atsakymas += "1. 5 kg mėsos dešrelių (reikia 5 kg mėsos ir 1 pakuotės)\n"
    atsakymas += "2. 10 kg mėsos dešrelių (reikia 10 kg mėsos ir 2 pakuočių)\n"
    atsakymas += "3. 20 kg mėsos dešrelių (reikia 20 kg mėsos ir 4 pakuočių)\n"

    if pasirinkimas not in ["1", "2", "3"]:
        atsakymas += "Neteisingas pasirinkimas gaminiui (1, 2, arba 3)!\n"
        return atsakymas

    try:
        daugiklis = int(kiek_vienetu_str)
    except ValueError:
        atsakymas += "Neteisinga įvestis! Reikia sveiko skaičiaus.\n"
        return atsakymas

    # Žemėlapiai
    kiekis_map = {"1": 5, "2": 10, "3": 20}
    pakuotes_map = {"1": 1, "2": 2, "3": 4}

    kiekis = kiekis_map[pasirinkimas]
    pakuotes = pakuotes_map[pasirinkimas]

    bendras_kiekis = kiekis * daugiklis
    bendros_pakuotes = pakuotes * daugiklis

    # Prieš gamindami, tikriname resursus
    if zaidejas.mesa >= bendras_kiekis and zaidejas.pakuotes >= bendros_pakuotes:
        zaidejas.mesa -= bendras_kiekis
        zaidejas.pakuotes -= bendros_pakuotes
        # Jei turite zaidejas.pagaminimai = [], galima append'inti
        atsakymas += (
          f"Pagaminote {bendras_kiekis} kg mėsos dešrelių ({daugiklis} "
          f"vienetai po {kiekis} kg).\n"
        )
    else:
        atsakymas += "Nepakanka resursų gamybai!\n"

    return atsakymas



##############################################################################
# Pagrindinė (vienkartinė) informacija, kurią norime rodyti "non-stop"


def suformuok_meniu(zaidejas):
    pranesimas1 = (
        f"\n                 ---------------"
        f"\n                | UAB ŠLAPIANKA |\n"
        f"                 ---------------\n"
        f"\n "
        f"         ) ) )                     ) ) )\n"\
        f"        ( ( (                      ( ( (\n"\
        f"      ) ) )                       ) ) )\n"\
        f"   (~~~~~~~~~)                 (~~~~~~~~~)\n"\
        f"    | DEŠRA |                   | DEŠRA |\n"\
        f"    |       |                   |       |              TAISYKLĖS:\n"\
        f"    I      _._                  I       _._            1 diena žaidime = 30 sekundžių realiame gyvenime\n"\
        f"    I    /'   `\\                I     /'   `\\          20sek užsakymo vėlavimas - atimamas 1Eur iš piniginės\n"\
        f"    I   |   N   |               I    |   N   |\n"\
        f"    f   |   |~~~~~~~~~~~~~~|    f    |    |~~~~~~~~~~~~~~|\n"\
        f"  .'    |   ||~~~~~~~~|    |  .'     |    | |~~~~~~~~|   |\n"
        f"/'______|___||__###___|____|/'_______|____|_|__###___|___|\n"
        f"\n"
        f"\n"
        f"Žaidėjo vardas: {zaidejas.vardas}\n"
        f"BŪSENA:\nPinigai: {zaidejas.pinigai}€, "
        f"Mėsa: {zaidejas.mesa} kg, pakuotės: {zaidejas.pakuotes}.\n"
    )
    uzsakymai_tekstas = "\nUŽSAKYMAI:\n" + uzsakymu_sarasas_tekstu(zaidejas)
    pranesimas2 = (
        f"\nPasirinkite veiksmą:\n"
        f"1. Gaminti mėsos produktą\n"
        f"2. Parduotuves\n"
        f"3. Naujas užsakymas\n"
        f"4. Vykdyti užsakymą\n"
        f"0. Baigti žaidimą\n"
    )
    
    # Surenkame viską į vieną "didžiulį" tekstą
    return pranesimas1 + uzsakymai_tekstas + pranesimas2

###############################################################################

def valdykKlienta(klientoSoketas):
    try:
        # 1. Paklausiame vardo
        serverioPranesimas = "Sveiki... Koks Jūsų vardas?\n"
        klientoSoketas.sendall(serverioPranesimas.encode('utf-8'))

        atsakymas = klientoSoketas.recv(4096).decode('utf-8')
        if not atsakymas:
            raise Exception("Nepavyko gauti atsakymo. Klientas gal atsijungė?")

        vardas = atsakymas.strip()
        zaidejas = Klientas(vardas)

        # 2. Paleisti animaciją
        #rodyti_animacija_klientui(klientoSoketas)

        # 3. Pirmą kartą atsiunčiame meniu
        visas_meniu = suformuok_meniu(zaidejas)
        klientoSoketas.sendall(visas_meniu.encode('utf-8'))

        # 4. Pradedame ciklą laukti veiksmų
        while True:
            duomenys = klientoSoketas.recv(4096)
            if not duomenys:
                # Klientas atsijungė
                break

            komanda = duomenys.decode('utf-8').strip()
            if komanda == "0":
                klientoSoketas.sendall(b"Baigiam zaidima...\n")
                break

            elif komanda == "3":
                # Naujas užsakymas
                atsakymas_naujas = naujas_uzsakymas(zaidejas)
                klientoSoketas.sendall(atsakymas_naujas.encode('utf-8'))

            elif komanda == "1":
                # Paprašome kliento, pvz. "1 2"
                tekstas = (
                    "Mėsos produktų gamyba:\n"
                    "1. 5 kg mėsos dešrelių (5 kg mėsos, 1 pakuotė)\n"
                    "2. 10 kg mėsos dešrelių (10 kg mėsos, 2 pakuotės)\n"
                    "3. 20 kg mėsos dešrelių (20 kg mėsos, 4 pakuotės)\n"
                    "Pvz. '2 3' => gaminys Nr.2, 3 vienetai\n"
                )
                klientoSoketas.sendall(tekstas.encode('utf-8'))

                ats = klientoSoketas.recv(4096)
                if not ats:
                    break
                komanda_gamyba = ats.decode('utf-8').strip()

                ats_gamyba = gaminti_mesos_produktus(zaidejas, komanda_gamyba)
                klientoSoketas.sendall(ats_gamyba.encode('utf-8'))

            elif komanda == "2":
                # 2 reiškia "Parduotuves" - t.y. pirkti_resursus
                # bet mums reikia sužinoti, ar pasirinks 1 ar 2 (Ūkininką ar pakuočių parduotuvę).
                # Taigi paprašome kliento pasirinkimo
                klaus = (
                    "Parduotuvių pasirinkimai:\n"
                    "1. Ūkininkas Antanas - Mėsos 10 kg už 10€\n"
                    "2. Pakuočių parduotuvė - 5 pakuotės už 5€\n"
                    "Pasirinkite parduotuvę (1 arba 2):\n"
                )
                klientoSoketas.sendall(klaus.encode('utf-8'))

                duomenys2 = klientoSoketas.recv(4096)
                if not duomenys2:
                    break
                parduotuve = duomenys2.decode('utf-8').strip()

                # Dabar kviečiame pirkti_resursus(zaidejas, parduotuve)
                ats_pard = pirkti_resursus(zaidejas, parduotuve)
                klientoSoketas.sendall(ats_pard.encode('utf-8'))      

            elif komanda == "4":
                # Serveris klausia, kokį užsakymą (pvz. numeris -1)
                klausimas = "Įveskite užsakymo numerį, kurį norite vykdyti (pvz.: 1)?\n"
                klientoSoketas.sendall(klausimas.encode('utf-8'))

                ats = klientoSoketas.recv(4096)
                if not ats:
                    break
                uzsak_idx_str = ats.decode('utf-8').strip()

                # Konvertuojam į int, bet atminkim, kad serverio sąrašo indeksas yra 0-based,
                # o klientas dažnai veda 1-based. Todėl atimtume 1, kad gautume teisingą index.
                try:
                    uzsak_idx = int(uzsak_idx_str) - 1
                except ValueError:
                    klientoSoketas.sendall(b"Neteisingas uzsakymo indeksas!\n")
                    continue

                # Vykdome
                ats_vykdymas = vykdyti_uzsakyma(zaidejas, uzsak_idx)
                klientoSoketas.sendall(ats_vykdymas.encode('utf-8'))       

            else:
                klientoSoketas.sendall(b"Nezinoma komanda!\n")

            # ** Štai čia ** vėl atsiunčiame "visą meniu" atnaujintą
            visas_meniu = suformuok_meniu(zaidejas)
            klientoSoketas.sendall(visas_meniu.encode('utf-8'))

        # 5. Išsaugome statistiką
        rasykStatistika(zaidejas)

    except Exception as e:
        print("Klaida valdykKlienta:", e)
    finally:
        klientoSoketas.close()


###############################################################################



def startuokServeri():
    if os.path.exists(SOKETO_FAILAS):
        os.remove(SOKETO_FAILAS)

    if not os.path.exists(ZAIDIMO_STATISTIKA):
        failas = open(ZAIDIMO_STATISTIKA, 'w')
        failas.write('Vardas;lygis;taskai;Testo pradžios laikas;Testo baigimo laikas\n')      
        failas.close()

    serverioSoketas = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    serverioSoketas.bind(SOKETO_FAILAS)
    serverioSoketas.listen()

    print(f"Serveris įjungtas:  {SOKETO_FAILAS}")
    try:
        while True:
            klientoSoketas, _ = serverioSoketas.accept()
            print("Naujas klientas")
            valdykKlienta(klientoSoketas)
    except KeyboardInterrupt:
        print("\nServeris baigia darbą.")
    finally:
        serverioSoketas.close()
        os.remove(SOKETO_FAILAS)

if __name__ == "__main__":
    startuokServeri()
